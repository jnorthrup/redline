import re
import uuid
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Optional

@dataclass
class CodeSegment:
    """Represents a segment of code with boundary information."""
    start_line: int
    end_line: int
    content: str
    indent_level: int
    segment_type: str  # 'class' or 'function'
    name: str
    parent_name: Optional[str] = None
    segment_id: str = str(uuid.uuid4())[:8]

class PythonSegmenter:
    """Core engine for Python file segmentation and reassembly."""

    def __init__(self, file_path: str):
        self.file_path = Path(file_path)
        self.content = self.file_path.read_text()
        self.lines = self.content.splitlines()

    def detect_boundaries(self) -> List[CodeSegment]:
        """Identifies code segment boundaries using regex and indentation analysis."""
        segments = []
        current_class = None
        pattern = re.compile(r'^(\s*)(class|def)\s+(\w+)')

        i = 0
        while i < len(self.lines):
            line = self.lines[i]
            match = pattern.match(line)

            if match:
                indent, segment_type, name = match.groups()
                indent_level = len(indent)

                # Find segment end based on indentation
                end_line = i + 1
                while end_line < len(self.lines):
                    next_line = self.lines[end_line].rstrip()
                    if next_line and not next_line.isspace():
                        next_indent = len(next_line) - len(next_line.lstrip())
                        if next_indent <= indent_level:
                            break
                    end_line += 1

                # Create segment
                content = '\n'.join(self.lines[i:end_line])

                if segment_type == 'class':
                    current_class = name
                    parent_name = None
                else:  # function
                    parent_name = current_class

                segment = CodeSegment(
                    start_line=i,
                    end_line=end_line,
                    content=content,
                    indent_level=indent_level,
                    segment_type=segment_type,
                    name=name,
                    parent_name=parent_name
                )
                segments.append(segment)
                i = end_line
            else:
                i += 1

        return segments

    def slice_file(self, output_dir: str = 'sliced'):
        """Slices the Python file into separate files based on detected segments."""
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)

        segments = self.detect_boundaries()
        modified_content = self.content

        for segment in segments:
            # Generate filename
            filename = f"{segment.parent_name}_{segment.name}.py" if segment.parent_name else f"{segment.name}.py"
            file_path = output_path / filename

            # Write segment to file
            file_path.write_text(segment.content)

            # Replace segment in original with reference comments
            replacement = (
                f"# BEGIN_SEGMENT {segment.segment_id}\n"
                f"# Segmented to: {filename}\n"
                f"# END_SEGMENT {segment.segment_id}"
            )

            modified_content = modified_content.replace(
                segment.content,
                replacement
            )

        # Write modified original
        (output_path / f"{self.file_path.stem}_modified{self.file_path.suffix}").write_text(modified_content)

    def reassemble(self, modified_file: str, segment_dir: str = 'sliced') -> str:
        """Reassembles segmented files back into a single file."""
        modified_content = Path(modified_file).read_text()
        segment_path = Path(segment_dir)

        # Find all segment markers
        pattern = re.compile(r'# BEGIN_SEGMENT (.*?)\n.*?# END_SEGMENT \1', re.DOTALL)

        def replace_segment(match):
            segment_id = match.group(1)
            # Extract filename from the middle line
            filename_line = match.group(0).split('\n')[1]
            filename = filename_line.split(': ')[1]

            # Read segment content
            segment_content = (segment_path / filename).read_text()
            return segment_content

        reassembled = pattern.sub(replace_segment, modified_content)
        return reassembled

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Python file segmentation tool')
    parser.add_argument('file', help='Python file to segment')
    parser.add_argument('--output', '-o', default='sliced', help='Output directory')
    parser.add_argument('--reassemble', '-r', action='store_true', help='Reassemble from sliced files')

    args = parser.parse_args()

    if args.reassemble:
        segmenter = PythonSegmenter(args.file)
        reassembled = segmenter.reassemble(args.file, args.output)
        print(reassembled)
    else:
        segmenter = PythonSegmenter(args.file)
        segmenter.slice_file(args.output)
        print(f"Segmented files written to {args.output}/")

if __name__ == '__main__':
    main()
